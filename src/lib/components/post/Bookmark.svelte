<script lang="ts">
  import {accountsDb, db} from '$lib/db';
  import {_} from "svelte-i18n";
  import { liveQuery } from 'dexie';
  import { agent } from '$lib/stores';
  import { toast } from "svelte-sonner";
  import Menu from "$lib/components/ui/Menu.svelte";
  import {getAccountIdByDidFromDb} from "$lib/util";

  export let _agent = $agent;
  export let post;
  let cloudBookmarks = [];
  let relatedBookmarks = [];
  let isMenuOpen = false;
  let alreadyBookmarks = [];

  $: bookmarks = liveQuery(async () => {
      const bookmarks = await db.bookmarks
          .where('owner')
          .equals(_agent.did())
          .toArray();

      return bookmarks;
  })

  $: if (isMenuOpen) {
      getCloudBookmarks();
      getRelatedBookmarks();
      const res = db.feeds
          .where('uri')
          .equals(post.uri)
          .toArray()
          .then(result => {
              alreadyBookmarks = result;
          })
          .catch(error => {
              console.error(error);
          })
  }

  async function add(bookmarkId: string) {
      try {
          const id = await db.feeds.add({
              bookmark: bookmarkId,
              owner: _agent.did(),
              cid: post.cid,
              indexedAt: Date.now(),
              createdAt: post.record.createdAt,
              text: post.record.text,
              author: post.author.did,
              uri: post.uri,
          })

          toast.success($_('bookmark_add_success'));
      } catch (e) {
          if (e.name === 'ConstraintError') {
              toast.error($_('error_may_duplicate_bookmark'));
          } else {
              toast.error($_('error') + ': ' + e);
          }
      }

      isMenuOpen = false;
  }

  async function deleteBookmark(_id) {
      try {
          const id = await db.feeds.delete(_id);

          /* timelines.update(function (tls) {
              return tls.map(tl => {
                  return tl.filter(data => data.bookmarkId !== bookmarkId);
              });
          }); */

          toast.success($_('bookmark_delete_success'));
      } catch (e) {
          toast.error($_('error') + ': ' + e);
      }

      isMenuOpen = false;
  }
  
  async function getCloudBookmarks() {
      try {
          const accountId = await getAccountIdByDidFromDb(_agent.did());
          const account = await accountsDb.accounts.get(accountId);
          const bookmarks = account?.cloudBookmarks;
          cloudBookmarks = bookmarks || [];

          const res = await fetch(`${await _agent.getPdsUrl()}/xrpc/tech.tokimeki.bookmark.getBookmarks?owner=${_agent.did() as string}`, {
              method: 'GET',
              headers: {
                  'atproto-proxy': 'did:web:api.tokimeki.tech#tokimeki_api',
                  Authorization: 'Bearer ' + _agent.getToken(),
                  'Content-Type': 'application/json'
              }
          })

          if (res.status !== 200) {
              throw new Error('failed to get Cloud Bookmark');
          }

          const json = await res.json();

          cloudBookmarks = json.bookmarks;
      } catch (e) {
          cloudBookmarks = [];
      }
  }

  async function getRelatedBookmarks() {
      try {
          const res = await fetch(`${await _agent.getPdsUrl()}/xrpc/tech.tokimeki.bookmark.getRelatedBookmark?owner=${_agent.did() as string}&cid=${post.cid}`, {
              method: 'GET',
              headers: {
                  'atproto-proxy': 'did:web:api.tokimeki.tech#tokimeki_api',
                  Authorization: 'Bearer ' + _agent.getToken(),
                  'Content-Type': 'application/json'
              }
          })
          const json = await res.json();

          if (res.status !== 200) {
              throw new Error('failed to get Cloud Bookmark');
          }

          relatedBookmarks = json.bookmarks;
      } catch (e) {
          console.error(e);
      }
  }

  async function addCloud(id: string) {
      isMenuOpen = false;

      try {
          const res = await fetch(`${await _agent.getPdsUrl()}/xrpc/tech.tokimeki.bookmark.addBookmarkItem`, {
              method: 'POST',
              body: JSON.stringify({
                  bookmark: {
                      bookmark: id,
                      owner: _agent.did() as string,
                      cid: post.cid,
                      uri: post.uri,
                  }
              }),
              headers: {
                  'atproto-proxy': 'did:web:api.tokimeki.tech#tokimeki_api',
                  Authorization: 'Bearer ' + _agent.getToken(),
                  'Content-Type': 'application/json'
              }
          })

          if (res.status !== 200) {
              throw new Error('failed to add Cloud Bookmark');
          }

          toast.success($_('bookmark_save_success'));
      } catch (e) {
          toast.error('Error: ' + e);
      }
  }

  async function deleteCloud(id: string) {
      isMenuOpen = false;

      try {
          const res = await fetch(`${await _agent.getPdsUrl()}/xrpc/tech.tokimeki.bookmark.deleteBookmarkItem`, {
              method: 'POST',
              body: JSON.stringify({
                  bookmark: {
                      bookmark: id,
                      cid: post.cid,
                      owner: _agent.did() as string,
                  }
              }),
              headers: {
                  'atproto-proxy': 'did:web:api.tokimeki.tech#tokimeki_api',
                  Authorization: 'Bearer ' + _agent.getToken(),
                  'Content-Type': 'application/json'
              }
          })

          if (res.status !== 200) {
              throw new Error('failed to add Cloud Bookmark');
          }

          relatedBookmarks = relatedBookmarks.filter(_bookmark => _bookmark !== id);
          toast.success($_('bookmark_delete_success'));
      } catch (e) {
          toast.error('Error: ' + e);
      }
  }

  function toggleMenu() {
      isMenuOpen = !isMenuOpen;
  }
</script>

<div class="bookmark-wrap">
  <Menu bind:isMenuOpen={isMenuOpen} buttonClassName="timeline-reaction__item timeline-reaction__item--bookmark">
    <span class="timeline-reaction__icon" slot="ref">
         <svg xmlns="http://www.w3.org/2000/svg" width="12" height="15" viewBox="0 0 12 15">
      <path id="bookmark" d="M2,1.5A1.5,1.5,0,0,1,3.5,0h9A1.5,1.5,0,0,1,14,1.5V15L8,12,2,15Z" transform="translate(-2)" fill="var(--timeline-reaction-bookmark-icon-color)"/>
    </svg>
    </span>

    <ul slot="content" class="timeline-menu-list">
      {#if ($bookmarks)}
        {#each $bookmarks as bookmark}
          <li class="timeline-menu-list__item timeline-menu-list__item--mute">
            {#if (alreadyBookmarks.some(already => already.bookmark === bookmark.id))}
              <li class="timeline-menu-list__item timeline-menu-list__item--mute">
                <button class="timeline-menu-list__button timeline-menu-list__button--bookmark" on:click={() => {deleteBookmark(alreadyBookmarks[0].id)}}>
                  {bookmark.name}
                  <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="var(--danger-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                </button>
              </li>
            {:else}
              <button class="timeline-menu-list__button timeline-menu-list__button--bookmark" on:click={() => {add(bookmark.id)}}>
                {bookmark.name}
              </button>
            {/if}
          </li>
        {:else}
          {#if (!cloudBookmarks.length)}
            <li class="timeline-menu-list__item timeline-menu-list__item--mute">
              <button class="timeline-menu-list__button timeline-menu-list__button--bookmark">{$_('no_bookmark_folder')}</button>
            </li>
          {/if}
        {/each}
      {/if}

      {#if cloudBookmarks}
        {#each cloudBookmarks as bookmark}
          {#if !relatedBookmarks.includes(bookmark.id)}
            <li class="timeline-menu-list__item timeline-menu-list__item--mute">
              <button class="timeline-menu-list__button timeline-menu-list__button--bookmark" on:click={() => {addCloud(bookmark.id)}}>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cloud"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>
                {bookmark.name}
              </button>
            </li>
          {:else}
            <li class="timeline-menu-list__item timeline-menu-list__item--mute">
              <button class="timeline-menu-list__button timeline-menu-list__button--bookmark" on:click={() => {deleteCloud(bookmark.id)}}>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cloud"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>
                {bookmark.name}
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="var(--danger-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
              </button>
            </li>
          {/if}
        {/each}
      {/if}
    </ul>
  </Menu>
</div>

<style lang="postcss">
  .bookmark-wrap {
      position: relative;
  }
</style>